"""
Vulnerability API.

"""

# Third-Party Libraries
from django.core.paginator import Paginator
from django.db.models import Q
from fastapi import HTTPException

from ..auth import (
    get_org_memberships,
    get_user_domains,
    get_user_organization_ids,
    is_global_view_admin,
)
from ..helpers.filter_helpers import filter_vulnerabilities, sort_direction
from ..models import Vulnerability
from ..schema_models.vulnerability import Vulnerability as VulnerabilitySchema
from ..schema_models.vulnerability import VulnerabilityFilters, VulnerabilitySearch


def get_vulnerability_by_id(vuln_id):
    """
    Get vulnerability by id.
    Returns:
        object: a single Vulnerability object.
    """
    try:
        vulnerability = Vulnerability.objects.get(id=vuln_id)
        return vulnerability
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


def update_vulnerability(vuln_id, data: VulnerabilitySchema):
    """
    Update vulnerability by id.

    Returns:
        object: a single vulnerability object that has been modified.
    """
    try:
        vulnerability = Vulnerability.objects.get(id=vuln_id)
        vulnerability = data
        vulnerability.save()
        return vulnerability
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


def search_vulnerabilities(vulnerability_search: VulnerabilitySearch, current_user):
    """
    List vulnerabilities by search filter
    Arguments:
        vulnerability_search: A VulnerabilitySearch object to filter by.
    Returns:
        object: A paginated list of Vulnerability objects
    """
    try:
        # Fetch all domains in list
        vulnerabilities = Vulnerability.objects.all().order_by(
            sort_direction(vulnerability_search.sort, vulnerability_search.order)
        )

        # Permissions check
        if not is_global_view_admin(current_user):
            org_ids = get_org_memberships(current_user)
            if not org_ids:
                return [], 0  # User has no accessible organizations
            vulnerabilities = vulnerabilities.filter(
                domain__organization_id__in=org_ids
            )

        # Apply custom FCEB and CIDR filter
        vulnerabilities = vulnerabilities.filter(
            Q(domain__isFceb=True) | Q(domain__isFceb=False, domain__fromCidr=True)
        )

        if vulnerability_search.filters:
            vulnerabilities = filter_vulnerabilities(
                vulnerabilities, vulnerability_search.filters
            )

        if vulnerability_search.groupBy:
            vulnerabilities = vulnerabilities.values(
                vulnerability_search.groupBy
            ).order_by()

        paginator = Paginator(vulnerabilities, vulnerability_search.pageSize)
        return paginator.get_page(vulnerability_search.page)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


def export_vulnerabilities(vulnerability_filters: VulnerabilityFilters):
    try:
        vulnerabilities = Vulnerability.objects.all()

        if vulnerability_filters:
            vulnerabilities = filter_vulnerabilities(
                vulnerabilities, vulnerability_filters
            )

        # TODO: Integrate methods to generate CSV from queryset and save to S3 bucket
        return vulnerabilities
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


async def get_num_vulns(current_user, redis_client):
    """Retrieve Stats from Elasticache."""
    try:
        # Step 1: Retrieve the list of domain names associated with the user
        user_domains = await get_user_domains(current_user)
        # print(user_domains)

        if not user_domains:
            raise HTTPException(
                status_code=404, detail="No domains found for the user."
            )

        # Step 2: Retrieve all vulnerability stats data from Redis
        vulnerabilities_stats = await redis_client.get("num_vulnerabilities_stats")

        if not vulnerabilities_stats:
            raise HTTPException(
                status_code=404, detail="No vulnerabilities stats data found in cache."
            )

        # Step 3: Filter the vulnerabilities stats based on user's domains
        filtered_data = []
        for composite_id, value in vulnerabilities_stats.items():
            try:
                domain, severity = composite_id.split("|", 1)
            except ValueError:
                # If the composite_id doesn't contain '|', skip this entry
                continue

            if domain in user_domains:
                filtered_data.append({"id": composite_id, "value": int(value)})

        if not filtered_data:
            raise HTTPException(
                status_code=404,
                detail="No vulnerability data found for the user in cache.",
            )

        return filtered_data

    except aioredis.RedisError as redis_error:
        raise HTTPException(status_code=500, detail=f"Redis error: {redis_error}")

    except HTTPException as http_exc:
        raise http_exc  # Already handled, re-raise

    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"An unexpected error occurred: {e}"
        )


async def stats_latest_vulns(organization, tag, current_user, redis_client):
    """Retrieve the latest vulnerability stats from Elasticache."""
    try:
        # Step 1: Retrieve data from Redis
        vulnerabilities_json = await redis_client.get("latest_vulnerabilities")

        if vulnerabilities_json is None:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, detail="Data not found in cache."
            )

        # Deserialize JSON data
        if isinstance(vulnerabilities_json, bytes):
            vulnerabilities_json = vulnerabilities_json.decode("utf-8")
        vulnerabilities_data = json.loads(vulnerabilities_json)

        # Validate data format
        if not isinstance(vulnerabilities_data, list):
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail="Unexpected data format.",
            )

        # Get user's organization IDs
        user_org_ids = await get_user_organization_ids(current_user)
        if not user_org_ids:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="User does not belong to any organizations.",
            )

        # Check if user is a global admin
        is_admin = is_global_view_admin(current_user)

        # Determine accessible organizations
        if is_admin:
            accessible_org_ids = None  # None implies access to all organizations
        else:
            accessible_org_ids = set(user_org_ids)

        # Apply filters
        if organization:
            if (
                accessible_org_ids is not None
                and organization not in accessible_org_ids
            ):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="User does not have access to the specified organization.",
                )
            accessible_org_ids = {organization}
        elif tag:
            tag_org_ids = get_tag_organization_ids(tag)
            if accessible_org_ids is not None:
                accessible_org_ids = accessible_org_ids.intersection(tag_org_ids)
            else:
                accessible_org_ids = set(tag_org_ids)
            if not accessible_org_ids:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="No accessible organizations found for the specified tag.",
                )

        # Filter vulnerabilities based on accessible organizations
        if accessible_org_ids is not None:
            filtered_vulnerabilities = [
                vuln
                for vuln in vulnerabilities_data
                if vuln.get("organizationId") in accessible_org_ids
            ]
        else:
            filtered_vulnerabilities = vulnerabilities_data

        return filtered_vulnerabilities

    except json.JSONDecodeError:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to parse JSON data from cache.",
        )
    except aioredis.RedisError as redis_err:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Redis error: {redis_err}",
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=str(e)
        )


async def stats_most_common_vulns(organization, tag, current_user, redis_client):
    """Retrieve the most common vulnerabilities from Elasticache."""
    try:
        # Retrieve data from Redis
        vulnerabilities_json = await redis_client.get("most_common_vulnerabilities")

        if vulnerabilities_json is None:
            raise HTTPException(status_code=404, detail="Data not found in cache.")

        # Deserialize JSON data
        if isinstance(vulnerabilities_json, bytes):
            vulnerabilities_json = vulnerabilities_json.decode("utf-8")
        vulnerabilities_data = json.loads(vulnerabilities_json)

        # Validate data format
        if not isinstance(vulnerabilities_data, list):
            raise HTTPException(status_code=500, detail="Unexpected data format.")

        # Get user's organization IDs
        user_org_ids = await get_user_organization_ids(current_user)
        print(user_org_ids)
        if not user_org_ids:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="User does not belong to any organizations.",
            )

        # Check if user is a global admin
        is_admin = is_global_view_admin(current_user)

        # Determine accessible organizations
        if is_admin:
            accessible_org_ids = None  # None implies access to all organizations
        else:
            accessible_org_ids = set(user_org_ids)

        # Apply filters
        if organization:
            if (
                accessible_org_ids is not None
                and organization not in accessible_org_ids
            ):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="User does not have access to the specified organization.",
                )
            accessible_org_ids = {organization}
        elif tag:
            tag_org_ids = get_tag_organization_ids(tag)
            if accessible_org_ids is not None:
                accessible_org_ids = accessible_org_ids.intersection(tag_org_ids)
            else:
                accessible_org_ids = set(tag_org_ids)
            if not accessible_org_ids:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="No accessible organizations found for the specified tag.",
                )

        # Filter vulnerabilities based on accessible organizations
        if accessible_org_ids is not None:
            filtered_vulnerabilities = [
                vuln
                for vuln in vulnerabilities_data
                if vuln.get("organizationId") in accessible_org_ids
            ]
        else:
            filtered_vulnerabilities = vulnerabilities_data

        return filtered_vulnerabilities

    except json.JSONDecodeError:
        raise HTTPException(
            status_code=500, detail="Failed to parse JSON data from cache."
        )
    except aioredis.RedisError as redis_err:
        raise HTTPException(status_code=500, detail=f"Redis error: {redis_err}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


async def stats_vuln_count(organization, tag, current_user, redis_client):
    """Retrieve vulnerability count"""

    try:
        # Retrieve data from Redis
        vulnerabilities_json = await redis_client.get("vulnerabilities_data")

        if vulnerabilities_json is None:
            raise HTTPException(status_code=404, detail="Data not found in cache.")

        # Deserialize JSON data
        vulnerabilities_data = json.loads(vulnerabilities_json)

        # Get user's organization IDs
        user_org_ids = await get_user_organization_ids(current_user)
        if not user_org_ids:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="User does not belong to any organizations.",
            )

        # Check if user is a global admin
        is_admin = is_global_view_admin(current_user)

        # Determine accessible organizations
        if is_admin:
            accessible_org_ids = None  # None implies access to all organizations
        else:
            accessible_org_ids = set(user_org_ids)

        # Apply filters
        if organization:
            if (
                accessible_org_ids is not None
                and organization not in accessible_org_ids
            ):
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="User does not have access to the specified organization.",
                )
            accessible_org_ids = {organization}
        elif tag:
            tag_org_ids = get_tag_organization_ids(tag)
            if accessible_org_ids is not None:
                accessible_org_ids = accessible_org_ids.intersection(tag_org_ids)
            else:
                accessible_org_ids = set(tag_org_ids)
            if not accessible_org_ids:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail="No accessible organizations found for the specified tag.",
                )

        # Filter vulnerabilities based on accessible organizations
        if accessible_org_ids is not None:
            filtered_vulnerabilities = [
                vuln
                for vuln in vulnerabilities_data
                if vuln.get("organizationId") in accessible_org_ids
            ]
        else:
            filtered_vulnerabilities = vulnerabilities_data

        # Aggregate counts by severity
        severity_counts = {}
        for vuln in filtered_vulnerabilities:
            severity = vuln.get("severity")
            if severity not in severity_counts:
                severity_counts[severity] = 0
            severity_counts[severity] += 1

        # Transform to list of dictionaries
        severity_data = [
            {"id": severity, "value": count, "label": severity}
            for severity, count in severity_counts.items()
        ]

        return severity_data

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

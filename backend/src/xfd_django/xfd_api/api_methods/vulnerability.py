"""
Vulnerability API.

"""
# Standard Python Libraries
import uuid

# Third-Party Libraries
from django.core.paginator import Paginator
from django.db.models import Q
from django.shortcuts import get_object_or_404
from fastapi import HTTPException
from redis import asyncio as aioredis

from ..auth import get_org_memberships, get_stats_org_ids, is_global_view_admin
from ..helpers.filter_helpers import filter_vulnerabilities, sort_direction
from ..helpers.stats_helpers import get_stats_count_from_cache
from ..models import Domain, Service, Vulnerability
from ..schema_models.vulnerability import Vulnerability as VulnerabilitySchema
from ..schema_models.vulnerability import VulnerabilityFilters, VulnerabilitySearch


def is_valid_uuid(val: str) -> bool:
    """Check if the given string is a valid UUID."""
    try:
        uuid_obj = uuid.UUID(val, version=4)
    except ValueError:
        return False
    return str(uuid_obj) == val


def get_vulnerability_by_id(vulnerability_id):
    """
    Get vulnerability by id.
    Returns:
        object: a single Vulnerability object.
    """
    try:
        vulnerability = Vulnerability.objects.get(id=vulnerability_id)
        return vulnerability
    except Vulnerability.DoesNotExist:
        raise HTTPException(status_code=404, detail="Vulnerability not found.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


def update_vulnerability(
    vulnerability_id, vulnerability_data: VulnerabilitySchema, current_user
):
    """
    Update vulnerability by id.

    Args:
        vulnerability_id (UUID): The ID of the vulnerability to update.
        vulnerability_data (VulnerabilitySchema): The data to update the vulnerability with.
        current_user: The user performing the update (not used in this snippet, but can be used for auditing).

    Returns:
        Vulnerability: The updated vulnerability object.

    Raises:
        HTTPException: If the vulnerability is not found or if a server error occurs.
    """
    try:
        # Validate the vulnerability ID
        if not is_valid_uuid(vulnerability_id):
            raise HTTPException(status_code=404, detail="Vulnerability not found")

        # Fetch the existing vulnerability
        vulnerability = Vulnerability.objects.get(id=vulnerability_id)

        # Create a mapping of fields to update
        fields_to_update = {
            "title": vulnerability_data.title,
            "cve": vulnerability_data.cve,
            "cwe": vulnerability_data.cwe,
            "cpe": vulnerability_data.cpe,
            "description": vulnerability_data.description,
            "references": vulnerability_data.references,
            "cvss": vulnerability_data.cvss,
            "severity": vulnerability_data.severity,
            "needsPopulation": vulnerability_data.needsPopulation,
            "state": vulnerability_data.state,
            "substate": vulnerability_data.substate,
            "source": vulnerability_data.source,
            "notes": vulnerability_data.notes,
            "actions": vulnerability_data.actions,
            "structuredData": vulnerability_data.structuredData,
            "isKev": vulnerability_data.isKev,
            "domain": vulnerability_data.domain_id,
            "service": vulnerability_data.service_id,
        }

        # Update fields that are not None
        for field, value in fields_to_update.items():
            if value is not None:
                if field == "domain":
                    # Handle domain ID to fetch the Domain instance
                    domain_instance = get_object_or_404(
                        Domain, id=vulnerability_data.domain_id
                    )
                    vulnerability.domain = domain_instance
                elif field == "service":
                    # Handle service ID to fetch the Service instance
                    service_instance = get_object_or_404(
                        Service, id=vulnerability_data.service_id
                    )
                    vulnerability.service = service_instance
                else:
                    setattr(vulnerability, field, value)

        # Save the updated vulnerability object
        vulnerability.save()

        return vulnerability

    except Vulnerability.DoesNotExist:
        raise HTTPException(status_code=404, detail="Vulnerability not found.")
    except Exception as e:
        raise HTTPException(status_code=500, detail="Internal Server Error")


def search_vulnerabilities(vulnerability_search: VulnerabilitySearch, current_user):
    """
    List vulnerabilities by search filter
    Arguments:
        vulnerability_search: A VulnerabilitySearch object to filter by.
    Returns:
        object: A paginated list of Vulnerability objects
    """
    try:
        # Fetch all domains in list
        vulnerabilities = Vulnerability.objects.all().order_by(
            sort_direction(vulnerability_search.sort, vulnerability_search.order)
        )

        # Permissions check
        if not is_global_view_admin(current_user):
            org_ids = get_org_memberships(current_user)
            if not org_ids:
                return [], 0  # User has no accessible organizations
            vulnerabilities = vulnerabilities.filter(
                domain__organization_id__in=org_ids
            )

        # Apply custom FCEB and CIDR filter
        vulnerabilities = vulnerabilities.filter(
            Q(domain__isFceb=True) | Q(domain__isFceb=False, domain__fromCidr=True)
        )

        if vulnerability_search.filters:
            vulnerabilities = filter_vulnerabilities(
                vulnerabilities, vulnerability_search.filters
            )

        if vulnerability_search.groupBy:
            vulnerabilities = vulnerabilities.values(
                vulnerability_search.groupBy
            ).order_by()

        paginator = Paginator(vulnerabilities, vulnerability_search.pageSize)
        return paginator.get_page(vulnerability_search.page)
    except Vulnerability.DoesNotExist as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


def export_vulnerabilities(vulnerability_filters: VulnerabilityFilters):
    try:
        vulnerabilities = Vulnerability.objects.all()

        if vulnerability_filters:
            vulnerabilities = filter_vulnerabilities(
                vulnerabilities, vulnerability_filters
            )

        # TODO: Integrate methods to generate CSV from queryset and save to S3 bucket
        return vulnerabilities
    except Vulnerability.DoesNotExist as e:
        raise HTTPException(status_code=404, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

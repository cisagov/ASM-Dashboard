"""Vulnerability API."""
# Standard Python Libraries
import csv
import io
import uuid

# Third-Party Libraries
from django.core.paginator import Paginator
from django.db.models import Count, Q
from django.shortcuts import get_object_or_404
from fastapi import HTTPException

from ..auth import get_org_memberships, is_global_view_admin
from ..helpers.filter_helpers import apply_vuln_filters, sort_direction
from ..helpers.s3_client import S3Client
from ..models import Domain, Service, Vulnerability
from ..schema_models.vulnerability import (
    VulnerabilityFilters,
    VulnerabilityGroupResponse,
    VulnerabilitySearch,
)
from ..schema_models.vulnerability import GetVulnerabilityResponse
from ..schema_models.vulnerability import Vulnerability as VulnerabilitySchema


def is_valid_uuid(val: str) -> bool:
    """Check if the given string is a valid UUID."""
    try:
        uuid_obj = uuid.UUID(val, version=4)
    except ValueError:
        return False
    return str(uuid_obj) == val


def get_vulnerability_by_id(vulnerability_id, current_user):
    """Get vulnerability by id."""
    try:
        # Initialize a VulnerabilitySearch with filters.id set to the vulnerability_id
        search = VulnerabilitySearch(
            page=1,
            sort="ASC",
            order="id",
            filters=VulnerabilityFilters(id=str(vulnerability_id)),
        )
        vulnerabilities, count = search_vulnerabilities(search, current_user)

        if count == 0:
            raise HTTPException(status_code=404, detail="Vulnerability not found.")

        # Assuming vulnerabilities is a list, get the first (and only) item
        vulnerability = vulnerabilities[0]

        # Serialize using Pydantic model
        return GetVulnerabilityResponse.from_orm(vulnerability)

    except HTTPException as he:
        raise he
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


def update_vulnerability(
    vulnerability_id, vulnerability_data: VulnerabilitySchema, current_user
):
    """Update vulnerability by id."""
    try:
        if not is_global_view_admin(current_user):
            raise HTTPException(status_code=401, detail="Unauthorized")

        # Validate the vulnerability ID
        if not is_valid_uuid(vulnerability_id):
            raise HTTPException(status_code=404, detail="Vulnerability not found")

        # Fetch the existing vulnerability
        vulnerability = Vulnerability.objects.get(id=vulnerability_id)

        # Create a mapping of fields to update
        fields_to_update = {
            "title": vulnerability_data.title,
            "cve": vulnerability_data.cve,
            "cwe": vulnerability_data.cwe,
            "cpe": vulnerability_data.cpe,
            "description": vulnerability_data.description,
            "references": vulnerability_data.references,
            "cvss": vulnerability_data.cvss,
            "severity": vulnerability_data.severity,
            "needsPopulation": vulnerability_data.needsPopulation,
            "state": vulnerability_data.state,
            "substate": vulnerability_data.substate,
            "source": vulnerability_data.source,
            "notes": vulnerability_data.notes,
            "actions": vulnerability_data.actions,
            "structuredData": vulnerability_data.structuredData,
            "isKev": vulnerability_data.isKev,
            "domain": vulnerability_data.domain_id,
            "service": vulnerability_data.service_id,
        }

        # Update fields that are not None
        for field, value in fields_to_update.items():
            if value is not None:
                if field == "domain":
                    # Handle domain ID to fetch the Domain instance
                    domain_instance = get_object_or_404(
                        Domain, id=vulnerability_data.domain_id
                    )
                    vulnerability.domain = domain_instance
                elif field == "service":
                    # Handle service ID to fetch the Service instance
                    service_instance = get_object_or_404(
                        Service, id=vulnerability_data.service_id
                    )
                    vulnerability.service = service_instance
                else:
                    setattr(vulnerability, field, value)
        # Save the updated vulnerability object
        vulnerability.save()
        return vulnerability

    except Vulnerability.DoesNotExist:
        raise HTTPException(status_code=404, detail="Vulnerability not found.")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Internal Server Error: {e}")


def search_vulnerabilities(vulnerability_search: VulnerabilitySearch, current_user):
    """List vulnerabilities by search filter."""
    try:
        # Base query with related data
        vulnerabilities = Vulnerability.objects.select_related(
            "domain", "domain__organization", "service"
        ).order_by(
            sort_direction(vulnerability_search.sort, vulnerability_search.order)
        )

        # Permissions check
        if not is_global_view_admin(current_user):
            org_ids = get_org_memberships(current_user)
            if not org_ids:
                return [], 0  # User has no accessible organizations
            vulnerabilities = vulnerabilities.filter(
                domain__organization_id__in=org_ids
            )

        # Apply custom FCEB and CIDR filter
        vulnerabilities = vulnerabilities.filter(
            Q(domain__isFceb=True) | Q(domain__isFceb=False, domain__fromCidr=True)
        )

        # Apply additional filters
        if vulnerability_search.filters:
            vulnerabilities = apply_vuln_filters(
                vulnerabilities, vulnerability_search.filters
            )

        # Apply grouping if specified
        if vulnerability_search.groupBy:
            vulnerabilities = (
                vulnerabilities.values(vulnerability_search.groupBy)
                .annotate(cnt=Count("id"))
                .order_by("-cnt")
            )

        # Paginate the results
        paginator = Paginator(vulnerabilities, vulnerability_search.pageSize)
        page_obj = paginator.get_page(vulnerability_search.page)

        # If groupBy is used, handle raw values
        if vulnerability_search.groupBy:
            result = list(page_obj)
            count = paginator.count
            return result, count

        result = list(page_obj.object_list)
        count = paginator.count
        return result, count

    except Vulnerability.DoesNotExist as e:
        print(e)
        raise HTTPException(status_code=404, detail="Vulnerability not found.")
    except Exception as e:
        print(e)
        raise HTTPException(status_code=500, detail=str(e))


def export_vulnerabilities(vulnerability_search, current_user):
    """Export vulnerabilities into a CSV and upload to S3."""
    try:
        # Retrieve vulnerabilities based on search filters
        vulnerability_search.pageSize = 1000  # Set to max 1000 results
        vulnerabilities, count = search_vulnerabilities(
            vulnerability_search, current_user
        )

        if vulnerability_search.groupBy:
            # Handle grouped data
            result = [
                VulnerabilityGroupResponse.model_validate(v) for v in vulnerabilities
            ]
            # Define CSV fields for grouped data
            group_field = vulnerability_search.groupBy
            csv_fields = [group_field, "cnt"]
            # Create CSV content
            output = io.StringIO()
            writer = csv.DictWriter(output, fieldnames=csv_fields)
            writer.writeheader()
            for v in result:
                row = {group_field: getattr(v, group_field, ""), "cnt": v.cnt}
                writer.writerow(row)
            csv_content = output.getvalue()
        else:
            # Serialize ORM instances to Pydantic models
            serialized_vulnerabilities = [
                GetVulnerabilityResponse.model_validate(v) for v in vulnerabilities
            ]
            # Convert to list of dictionaries
            data = [v.dict() for v in serialized_vulnerabilities]
            # Map organization and domain names
            for entry in data:
                entry["organization"] = (
                    entry["domain"]["organization"]["name"]
                    if entry.get("domain") and entry["domain"].get("organization")
                    else ""
                )
                entry["domain"] = entry["domain"]["name"] if entry.get("domain") else ""
            # Define CSV fields
            csv_fields = [
                "organization",
                "domain",
                "title",
                "description",
                "cve",
                "isKev",
                "cwe",
                "cpe",
                "cvss",
                "severity",
                "state",
                "substate",
                "lastSeen",
                "createdAt",
                "id",
            ]
            # Create CSV content
            output = io.StringIO()
            writer = csv.DictWriter(output, fieldnames=csv_fields)
            writer.writeheader()
            for entry in data:
                row = {field: entry.get(field, "") for field in csv_fields}
                writer.writerow(row)
            csv_content = output.getvalue()

        # Initialize S3 client
        client = S3Client()

        # Save CSV to S3
        url = client.save_csv(csv_content, "vulnerabilities")

        return {"url": url}

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
